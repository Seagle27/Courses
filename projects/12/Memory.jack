// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
	static int ram, heap, freeList;
	static Array heap;

    /** Initializes the class. */
    function void init() {
		let ram = 0;
		let heap = 2048;
		let freeList = 2048;
		let heap[0] = 0;  // Next
		let heap[1] = 14335;  // Length
		return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
		return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
		let ram[address] = value;
		return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
		var Array found, bestBlock, prevBlock;
		
		let prevBlock = Memory._bestFit(size);
		if (prevBlock = 0) {
			return null;  // No available block.
		}
		else {
			if (prevBlock = null) {
				let bestBlock = freeList;  // The best fit is the first block in the list.
			}
			else {
				let bestBlock = prevBlock[0];
			}
		}
		let prevBlock[0] = Memory.handleAllocation(size, bestBlock);
		return bestBlock + 2;
    }
	
	/** Finds the best fit for the required allocation size. return the
	 *  memory block that points to the best found block. */
	function Array _bestFit(int size) {
		var Array bestMatch, currentBlock, prevBlock;
		var int bestSize, currentSize;
		
		let currentBlock = freeList;
		let bestSize = 14336;
		let bestMatch = 0;
		let prevBlock = null;
		
		while( ~(currentBlock=0)) {
			let currentSize = currentBlock[1];
			if((currentSize > size +1) & (currentSize < bestMatch)) {
				let bestSize = currentSize;
				let bestMatch = prevBlock;
			}
			let prevBlock = currentBlock;
			let currentBlock = currentBlock[0]; //Next
		}
		
		return bestMatch;
	}
	
	
	function Array handleAllocation(int size, Array bestBlock) {
		var Array nextBlock;
		
		if (bestBlock[1] > (size + 3)) { // Allocate only part of the block
			let nextBlock = bestBlock + size + 2;
			let nextBlock[0] = bestBlock[0];
			let nextBlock[1] = bestBlock[1] - (nextBlock - bestBlock);
			
		}
		else {  // Allocate the entire block
			let nextBlock = bestBlock[0];
		}
		
		return nextBlock;
	}
	

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
		var Array currLastElement;
		
		let o = o - 2;
		let currLastElement = Memory.getLastFreeElement();
		if (currLastElement = null) {
			let freeList = o;
			let freeList[0] = 0;
		}
		else {
			let currLastElement[0] = o;
			let o[0] = 0;
		}
		return;
    }   

	function Array getLastFreeElement() {
		var Array element;
		
		let element = freeList;		
		while(~(element[0] = 0)) {
            let element = element[0];
        }
        return element;
	}
}
